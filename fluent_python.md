# Fluent Python 阅读笔记

## list/tuple是否是线程安全的？	
    
python的list和dict是否是线程安全的讨论

## 返回None	

如果一个函数或者方法对对象进行的是就地改动，那它就应该返回 None，好让调用者知道传入的参数发生了变动，而且并未产生新的对象。

弊端：用返回 None 来表示就地改动这个惯例有个弊端，那就是调用者无法将其串联起来。

## 排序算法

Timsort

Timsort——是稳定的。

根据原始数据的顺序特点交替使用插入排序和归并排 序，以达到最佳效率

## bisect

bisect 模块包含两个主要函数，bisect 和 insort，两个函数都利用 二分查找算法来在有序序列中查找或插入元素。

bisect 函数其实是 bisect_right 函数的别名，后者还有个姊妹函数叫 bisect_left。

## array.array	

需要一个只包含数字的列表，那么 array.array 比 list 更高效。数组支持所有跟可变序列有关的操作，包括 .pop、.insert 和 .extend。另外，数组还提供从文件读取和存入文件的更快的方法，如 .frombytes 和 .tofile。

Python 数组跟 C 语言数组一样精简。创建数组需要一个类型码，这个类 型码用来表示在底层的 C 语言应该存放怎样的数据类型。

## memoryview	

内存视图其实是泛化和去数学化的 NumPy 数组。它让你在不需要 复制内容的前提下，在数据结构之间共享内存。其中数据结构可以 是任何形式，比如 PIL 图片、SQLite 数据库和 NumPy 的数组，等 等。这个功能在处理大型数据集合的时候非常重要。(http://stackoverflow.com/questions/4845418/when-should-a- memoryview-be-used)

memoryview.cast 的概念跟数组模块类似，能用不同的方式读写同一 块内存数据，而且内容字节不会随意移动。这听上去又跟 C 语言中类型 转换的概念差不多。memoryview.cast 会把同一块内存里的内容打包成一个全新的 memoryview 对象给你。

利用数组来做高级的数字处理是你的日常工作，那么 NumPy 和 SciPy 应该是你的常用武器

## 其他queue	

collections.deque 类（双向队列）是一个线程安全、可以快速从两 端添加或者删除元素的数据类型
标准库queue提供了同步（线程安全）类 Queue、LifoQueue 和 PriorityQueue
heapq

## 字典	

如果一个对象是可散列的，那么在这个对象的生命周期中，它 的散列值是不变的，而且这个对象需要实现 __hash__() 方 法。另外可散列对象还要有 __qe__() 方法，这样才能跟其他 键做比较。如果两个可散列对象是相等的，那么它们的散列值 一定是一样的

一般来讲用户自定义的类型的对象都是可散列的，散列值就是它们 的 id() 函数的返回值，所以所有这些对象在比较的时候都是不相 等的。如果一个对象实现了 __eq__ 方法，并且在方法中用到了这 个对象的内部状态的话，那么只有当所有这些内部状态都是不可变 的情况下，这个对象才是可散列的。
dict、defaultdict 和 OrderedDict

当字典 d[k] 不能找到正确的键的时候，Python 会抛出异常，这个行为符合 Python 所信奉的“快速失败”哲学。my_dict.setdefault(key, []).append(new_value)

变种：

collections.OrderedDict 　　这个类型在添加键的时候会保持顺序，因此键的迭代次序总是一致的。
collections.ChainMap 该类型可以容纳数个不同的映射对象，然后在进行键查找操作的时候，这些对象会被当作一个整体被逐个查找，直到键被找到为止。这个功能在给有嵌套作用域的语言做解释器的时候很有用，可以用一个映射对象来代表一个作用域的上下文。

collections.Counter 这个映射类型会给键准备一个整数计数器。每次更新一个键的时候 都会增加这个计数器 most_common([n]) 这类很有用的方法

colllections.UserDict 　　这个类其实就是把标准 dict 用纯 Python 又实现了一遍。跟 OrderedDict、ChainMap 和 Counter 这些开箱即用的类型不 同，UserDict 是让用户继承写子类的。更倾向于从 UserDict 而不是从 dict 继承的主要原因是，后者有时 会在某些方法的实现上走一些捷径，导致我们不得不在它的子类中重写 这些方法，但是 UserDict 就不会带来这些问题。

从 Python 3.3 开始，types 模块中引入了一个封装类名叫MappingProxyType。如果给这个类一个映射，它会返回一个只读的映 射视图。虽然是个只读视图，但是它是动态的。这意味着如果对原映射 做出了改动，我们通过这个视图可以观察到，但是无法通过这个视图对 原映射做出修改

## 集合+字典	

表面上看，这个算法似乎很费事，而实际上就算 dict 里有数百万 个元素，多数的搜索过程中并不会有冲突发生，平均下来每次搜索 可能会有一到两次冲突。在正常情况下，就算是最不走运的键所遇 到的冲突的次数用一只手也能数过来。

不要根据 JSON 的风格，用由字典组成的列表来存放这些记录。用元组取代字典就能节省空间的原因有两个：其一是避免了散列表所耗费的空间，其二是无需把记录中字段的名字在每个元素里都存一遍。空间上的效率低下。举例而言，如果你需要存放数量巨大的记录，那么放在由元组或是具名元组构成的列表中会是比较好的选择。

由此可知，不要对字典同时进行迭代和修改。如果想扫描并修改一个字典，最好分成两步来进行：首先对字典迭代，以得出需要添加的内容，把这些内容放在一个新字典里；迭代结束之后再对原有字典进行更新。

键必须是可散列的 一个可散列的对象必须满足以下要求。
(1) 支持 hash() 函数，并且通过 __hash__() 方法所得到的散列 值是不变的。 (2) 支持通过 __eq__() 方法来检测相等性。 (3) 若 a == b 为真，则 hash(a) == hash(b) 也为真。
所有由用户自定义的对象默认都是可散列的，因为它们的散列值由 id() 来获取，而且它们都是不相等的。

## 文本处理	

如果想帮助自己记住 .decode() 和 .encode() 的区别，可以把字节序列想成晦涩难懂的机器磁芯转储，把 Unicode 字符串想 成“人类可读”的文本。那么，把字节序列变成人类可读的文本字符 串就是解码，而把字符串变成用于存储或传输的字节序列就是编 码。

struct 模块提供了一些函数，把打包的字节序列转换成不同类型字段 组成的元组，还有一些函数用于执行反向转换，把元组转换成打包的字节序列。struct 模块能处理 bytes、bytearray 和 memoryview 对象。

mmap —Memory-mapped file support”（https://docs.python.org/3/library/mmap.html）来进一步学习。

### 了解编解码问题：
 
多数非 UTF 编解码器只能处理 Unicode 字符的一小部分子集。把文本转 换成字节序列时，如果目标编码中没有定义某个字符，那就会抛出UnicodeEncodeError 异常，除非把 errors 参数传给编码方法或函 数，对错误进行特殊处理。

不是每一个字节都包含有效的 ASCII 字符，也不是每一个字符序列都是 有效的 UTF-8 或 UTF-16。因此，把二进制序列转换成文本时，如果假 设是这两个编码中的一个，遇到无法转换的字节序列时会抛出UnicodeDecodeError。

Python 3 默认使用 UTF-8 编码源码，Python 2（从 2.5 开始）则默认使用 ASCII。如果加载的 .py 模块中包含 UTF-8 之外的数据，而且没有声明 编码，会得到类似下面的消息：SyntaxError: Non-UTF-8 解决方法： shebang :# coding: ...

如何找出字节序列的编码？简单来说，不能。必须有人告诉你。

## 处理文本文件的最佳实践	

处理文本的最佳实践是“Unicode 三明治”（如图 4-2 所示）。 意思是，要尽早把输入（例如读取文件时）的字节序列解码成字符串。

```bash
---byte -> str （解码输入的字节序列）

---100%str (业务逻辑只处理文本）

---str -> byte (编码输出的文本）
```

内置的 open 函数会在读取文件时做必要的解码，以文本模式写入文件时还会做必要 的编码，所以调用 my_file.read() 方法得到的以及传给 my_file.write(text) 方法的都是字符串对象。
5Python 2.6 或 Python 2.7 用户要使用 io.open() 函数才能得到读写文件时自动执行的解码和编 码操作。


因此，关于编码默认值的最佳建议是：别依赖默认值。
